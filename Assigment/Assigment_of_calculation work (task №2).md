## Generating Set Partitions

### Description:
In this task, you are required to implement an algorithm that generates all possible partitions of a set {1, 2, ..., n} using an iterative method. The approach is based on the recurrence relation where each partition is generated by moving elements between blocks. The goal is to generate all these partitions iteratively by modifying existing partitions of {1, ..., n}.

### Theoretical Background:
A partition of a set {1, ..., n} can be represented by a sequence of blocks. For each partition of {1, ..., n-1}, partitions of {1, ..., n} can be generated by adding element `n` to any of the existing blocks or creating a new block for `n`. This process allows the systematic generation of all possible partitions of the set.

The recursive relationship for generating partitions can be described as follows:
- For a partition {B1, B2, ..., Bk} of {1, ..., n-1}, we generate partitions of {1, ..., n} by:
  - Adding `n` to an existing block.
  - Adding `n` as a new block.  
**The challenge is to implement this logic iteratively to produce all possible partitions.**

---

### Algorithm:
The algorithm generates all partitions of the set {1, 2, ..., n} iteratively by modifying a list of blocks. The partition is represented by a list where each element points to the block it belongs to. Active elements are moved between blocks to generate all possible partitions.

---

### Pseudocode:
```plaintext
begin
    for i := 1 to n do (*Place i in the first block*)
        BLOCK[i] := 1;
        FORWARD[i] := true;
    end;
    NEXT[1] := 0;
    print partition;

    j := n; (*j = active element*)
    while j > 1 do
        begin
            k := BLOCK[j];
            if FORWARD[j] then (*j moves forward*)
                begin
                    if NEXT[k] = 0 then (*k is the last block*)
                        begin NEXT[k] := j; PREV[j] := k; NEXT[j] := 0; end;
                    if NEXT[k] > j then (*j creates a new block*)
                        begin PREV[j] := k; NEXT[j] := NEXT[k]; PREV[NEXT[j]] := j; NEXT[k] := j; end;
                    BLOCK[j] := NEXT[k];
                end
            else (*j moves backward*)
                begin
                    BLOCK[j] := PREV[k];
                    if k = j then (*j forms a single-element block*)
                        if NEXT[k] = 0 then NEXT[PREV[k]] := 0
                        else begin NEXT[PREV[k]] := NEXT[k]; PREV[NEXT[k]] := PREV[k]; end;
                end;
            print partition;
            j := n;
            while (j > 1) and ((FORWARD[j] and (BLOCK[j] == j)) or (not FORWARD[j] and (BLOCK[j] == 1))) do
                begin FORWARD[j] := not FORWARD[j]; j := j - 1; end;
        end;
end;
```

### Task Requirements:
- **Implementation:** Implement an iterative algorithm to generate partitions of the set {1, 2, ..., n}. The elements of the set should be assigned to blocks in a way that all possible partitions are produced.
- **Partition Generation:** For each iteration, modify the block assignment to generate the next partition. Print the current partition after every modification.
- **Stopping Condition:** The process should stop when all elements are placed in their final blocks.

### Additional Requirements:
- **Efficiency:** Ensure the algorithm efficiently handles the generation of partitions, as the number of partitions grows exponentially with `n`.
- **Code Structure:** Maintain clear and modular code, with separate functions for printing partitions and managing the generation process.
- **Testing:** Test the algorithm with different values of `n` to verify that it correctly generates all possible partitions and displays them appropriately. 
